package agents

import (
	"encoding/json"
	"fmt"
	"strings"

	"github.com/MagdielCAS/magi-cli/internal/cli/pulumi/templates"
	"github.com/MagdielCAS/magi-cli/pkg/llm"
	"github.com/MagdielCAS/magi-cli/pkg/shared"
)

// PulumiGenerator generates Pulumi TypeScript code
type PulumiGenerator struct {
	*llm.MCPAgent
}

// GeneratedProject represents the generated Pulumi project
type GeneratedProject struct {
	ProjectFiles map[string]string `json:"project_files"`
	Dependencies []string          `json:"dependencies"`
	Instructions string            `json:"instructions"`
}

// NewPulumiGenerator creates a new Pulumi code generator
func NewPulumiGenerator(mcpClient *llm.MCPClient, runtime *shared.RuntimeContext) *PulumiGenerator {
	config := llm.MCPAgentConfig{
		Name: "Pulumi Code Generator",
		Task: `Generate a complete Pulumi TypeScript project based on the provided architecture analysis.

Create the following files:
1. Pulumi.yaml - Project configuration (Use the provided 'pulumi_yaml_template' as a base)
2. package.json - Node.js dependencies (Use the provided 'package_json_template' as a base)
3. tsconfig.json - TypeScript configuration (Use the provided 'tsconfig_template')
4. index.ts - Main infrastructure code
5. Additional TypeScript files for complex architectures
6. README.md - Setup and deployment instructions

Requirements:
- Use Pulumi AWS provider with TypeScript
- Follow AWS and Pulumi best practices from MCP context
- Include proper resource tagging and naming conventions
- Implement security best practices (IAM, encryption, VPC)
- Add comprehensive comments and documentation
- Use proper TypeScript types and interfaces
- Include error handling and validation
- Organize code into logical modules for complex projects
- You can use the provided 'aws_templates' as a reference for common resources, but adapt them to the specific requirements.

Ensure the generated code is production-ready and follows current Pulumi patterns.

IMPORTANT: You must return the result as a valid JSON object with the following structure:
{
  "project_files": {
    "filename": "content"
  },
  "dependencies": ["dep1", "dep2"],
  "instructions": "setup instructions"
}
Do not wrap the JSON in markdown code blocks. Return raw JSON only.`,
		Personality: "Senior DevOps engineer and Pulumi expert with extensive experience in AWS infrastructure automation. Skilled at writing clean, maintainable TypeScript code and following infrastructure best practices.",
		Tools:       []string{"get_resource_details"},
		MaxTokens:   8192,
	}

	mcpAgent := llm.NewMCPAgent(config, mcpClient, runtime)

	return &PulumiGenerator{
		MCPAgent: mcpAgent,
	}
}

// Generate creates Pulumi project code
func (g *PulumiGenerator) Generate(analysis *ArchitectureAnalysis, projectConfig map[string]string) (*GeneratedProject, error) {
	input := map[string]string{
		"architecture_analysis": g.serializeAnalysis(analysis),
		"project_name":          projectConfig["project_name"],
		"aws_region":            projectConfig["aws_region"],
		"output_directory":      projectConfig["output_directory"],
		"pulumi_yaml_template":  templates.GetPulumiYamlTemplate(projectConfig["project_name"], "Generated by magi-cli"),
		"package_json_template": templates.GetPackageJsonTemplate(projectConfig["project_name"]),
		"tsconfig_template":     templates.GetTsConfigTemplate(),
	}

	// Add AWS templates for reference
	awsTemplates := templates.GetAllTemplates()
	var templatesBuilder strings.Builder
	for name, content := range awsTemplates {
		templatesBuilder.WriteString(fmt.Sprintf("--- %s ---\n%s\n\n", name, content))
	}
	input["aws_templates"] = templatesBuilder.String()

	// Add resource types for MCP context
	resourceTypes := g.extractResourceTypesFromAnalysis(analysis)
	input["resource_types"] = strings.Join(resourceTypes, ",")

	result, err := g.AnalyzeWithMCP(input)
	if err != nil {
		return nil, fmt.Errorf("failed to generate Pulumi code: %w", err)
	}

	// Parse the generated project
	project, err := g.parseGeneratedProject(result)
	if err != nil {
		return nil, fmt.Errorf("failed to parse generated project: %w", err)
	}

	return project, nil
}

// serializeAnalysis converts analysis to string for LLM processing
func (g *PulumiGenerator) serializeAnalysis(analysis *ArchitectureAnalysis) string {
	var parts []string

	parts = append(parts, "=== SERVICES ===")
	for _, service := range analysis.Services {
		parts = append(parts, fmt.Sprintf("- %s (%s): %s", service.Name, service.Type, service.Description))
		if len(service.Dependencies) > 0 {
			parts = append(parts, fmt.Sprintf("  Dependencies: %s", strings.Join(service.Dependencies, ", ")))
		}
	}

	parts = append(parts, "\n=== NETWORKING ===")
	if analysis.Networking.VPC {
		parts = append(parts, "- VPC required")
		parts = append(parts, fmt.Sprintf("- Subnets: %s", strings.Join(analysis.Networking.Subnets, ", ")))
	}
	if analysis.Networking.LoadBalancer {
		parts = append(parts, "- Load Balancer required")
	}
	if analysis.Networking.CDN {
		parts = append(parts, "- CDN required")
	}

	parts = append(parts, "\n=== STORAGE ===")
	for _, db := range analysis.Storage.Databases {
		parts = append(parts, fmt.Sprintf("- Database: %s (%s), Size: %s, Backup: %t", db.Type, db.Engine, db.Size, db.Backup))
	}
	for _, storage := range analysis.Storage.FileStorage {
		parts = append(parts, fmt.Sprintf("- File Storage: %s, Access: %s, Encryption: %t", storage.Type, storage.AccessLevel, storage.Encryption))
	}

	parts = append(parts, "\n=== SECURITY ===")
	if len(analysis.Security.IAMRoles) > 0 {
		parts = append(parts, fmt.Sprintf("- IAM Roles: %s", strings.Join(analysis.Security.IAMRoles, ", ")))
	}
	parts = append(parts, fmt.Sprintf("- Encryption: %t", analysis.Security.Encryption))
	parts = append(parts, fmt.Sprintf("- VPC Endpoints: %t", analysis.Security.VPCEndpoints))
	parts = append(parts, fmt.Sprintf("- WAF: %t", analysis.Security.WAF))

	return strings.Join(parts, "\n")
}

// extractResourceTypesFromAnalysis gets AWS resource types from analysis
func (g *PulumiGenerator) extractResourceTypesFromAnalysis(analysis *ArchitectureAnalysis) []string {
	resourceTypes := []string{}

	// Add service types
	for _, service := range analysis.Services {
		resourceTypes = append(resourceTypes, service.Type)
	}

	// Add networking resources
	if analysis.Networking.VPC {
		resourceTypes = append(resourceTypes, "vpc", "subnet")
	}
	if analysis.Networking.LoadBalancer {
		resourceTypes = append(resourceTypes, "elb")
	}
	if analysis.Networking.CDN {
		resourceTypes = append(resourceTypes, "cloudfront")
	}

	// Add storage resources
	for range analysis.Storage.Databases {
		resourceTypes = append(resourceTypes, "rds")
	}
	for range analysis.Storage.FileStorage {
		resourceTypes = append(resourceTypes, "s3")
	}

	return resourceTypes
}

// parseGeneratedProject parses the LLM response into a structured project
func (g *PulumiGenerator) parseGeneratedProject(result string) (*GeneratedProject, error) {
	// Clean up result if it contains markdown code blocks
	result = strings.TrimSpace(result)
	if strings.HasPrefix(result, "```json") {
		result = strings.TrimPrefix(result, "```json")
		result = strings.TrimSuffix(result, "```")
	} else if strings.HasPrefix(result, "```") {
		result = strings.TrimPrefix(result, "```")
		result = strings.TrimSuffix(result, "```")
	}
	result = strings.TrimSpace(result)

	var project GeneratedProject
	if err := json.Unmarshal([]byte(result), &project); err != nil {
		return nil, fmt.Errorf("failed to parse generated project JSON: %w\nResponse was: %s", err, result)
	}

	return &project, nil
}
